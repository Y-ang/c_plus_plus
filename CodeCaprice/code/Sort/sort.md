#### 归并排序

https://blog.csdn.net/weixin_43222324/article/details/108385777

#### 堆排序

堆的结构是一个完全二叉树

| i 节点 | 左孩子 2\*i+1 | 右孩子 2\*i + 2 | 父节点 (i - 1) / 2 |
| ------ | ------------- | --------------- | ------------------ |

##### 大根堆

每颗子树的头节点是最大值

##### 小根堆

每颗子树的头节点是最小值

push向上调整，pop向下调整

向下调整: 与左右孩子比较，左右孩子都大于/小于根节点时可提前退出循环（因此，要保证根节点之后的子树为小根/大根堆）

向上调整: 与父节点比较，比较不满足条件时退出循环

##### 堆排序

在已经拥有一整个需要排序的数组时，可以使用**向下调整**，从数组末尾依次调整该节点的子树上为大根/小根堆  复杂度为O(n)

在一个一个插入元素时，使用**向上调整**，每进来一个元素调整一次    复杂度为O(nlogn)

步骤：1. 先将整个需要排序的数组建立一个大根/小根堆（升序：大根堆，降序：小根堆）；建立方法：向下调整（O(N)）, 向上调整(O(NlogN))

    2.  将堆顶元素和堆底元素交换，堆的长度减一，将堆顶元素**向下调整  O(NlogN)**

#### 快排

左小 中等 右大

1. 每次选当前区域的最后一个值作为划分值
2. 每次随机选一个值作为划分值(真正的快排), 将选出来的数与最后一个数交换, 再进行快排. 避免最差情况: 数组升序或降序, 每次只能调整一个值 (坏情况和好情况以概率1/N出现)

步骤:

1. 小于区边界: left - 1; 大于区边界: right(因为right位置上的数为用于划分区域的比较数)
2. 比较当前值和比较数的大小
   1. 当前数 > 比较数: 当前数与大于区左一个数交换, 大于区向左移动, 减1
   2. 当前数 < 比较数: 当前数与小于区右一个数交换, 小于区向右移动, 加1
   3. 当前数 = 比较数: index++
3. 返回小于边界, 大于边界, 用于下一次的递归排序
